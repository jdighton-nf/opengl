OpenGl is an interface that your application can use to access the underlying graphics hardware. 

I think I need to camp on the pre-processor for a while: 
Lets say you have 3 files. main.cpp, engine.cpp, and car.cpp.

Possible that car.cpp might need to know about engines, so you might #include engine.cpp
The issue is that engine.cpp is already included in main. You you end up with a definition, which is not allowed. 
File guards prevent this unintended recursion from carrying on. 

When we were programming with Python and OpenGl we used a wrapper library called pyOpenGl, and another library called PyGame. 
PyGame provided us with usefull tools for loading and preparing images, as well as with the ability to handle input, have a window, sound etc. 

When working with C++ we use include GL/gl3w.h which is loads OpenGL, we also use GLFW/glfw3.h which provides utilities like windowing, input, etc. 

Pipelining and parallelism are the name of the game. 

Had to do a basic tutorial on Cmake because I have no idea what's going on. 
- Update, cmake now makes sense. 

Had to spend sometime reviewing the code for gl3w to understand what was happening. 
Basically it downloads to latest ARB header and loads pointers to all the OpenGl functions
using glXGetProcAddress()

Spend some time studying the code for the sb7 framework and it pretty well makes sense now. 
Simply put it does the following: 
-get glfw3 for handling windows, input, and context
-create the window
-make the window the current context
-load pointers to all the GL functions
-declare some basic functions 
-establish basic flow and gives us a template to work with 
-declare a pointer to an instance of an application which is a pure virtual, this
prevents a 'bare' instantiation. 
